% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/setup-python-pkgs.R
\name{setup_py_env}
\alias{setup_py_env}
\alias{install_py_pkgs}
\alias{get_conda_paths}
\title{Set up a python environment with required packages}
\usage{
setup_py_env(
  py_pkgs = c("scipy", "pandas"),
  python_version = NULL,
  py_env = c("conda", "virtual"),
  env_name = PYTHON_R_ENV,
  conda_env = get_conda_envs(),
  conda_path = NULL,
  update = FALSE,
  pip = FALSE,
  required = TRUE
)

install_py_pkgs(
  py_pkgs = c("scipy", "pandas"),
  py_env = c("conda", "virtual"),
  conda_path = NULL,
  env_name = PYTHON_R_ENV,
  pip = FALSE,
  update = FALSE,
  python_version = NULL
)

get_conda_paths()
}
\arguments{
\item{py_pkgs}{vector of python packages to install}

\item{python_version}{The requested Python version. Ignored when attempting
to install with a Python virtual environment.}

\item{py_env}{Environment type. Either a conda or virtual environment.}

\item{env_name}{an environment name to use for \strong{new} virtual or conda environments.}

\item{conda_env}{path of the conda environment to use if \code{py_env = "conda"}.
Run \code{reticulate::conda_list()} to see a list of available conda environments.
The \code{conda_env} should match the \code{python} element of that list if you are loading
\emph{an existing} conda environment. If \code{conda_env} is not found in this list, a new
one will be created matching the name of \code{env_name}.}

\item{conda_path}{The path to a conda executable. If \code{NULL}, will default to the first one found.
See \code{get_conda_paths()} for details.}

\item{update}{Logical (\code{TRUE}/\code{FALSE}). If \code{TRUE}, update packages that are
already installed. Otherwise skip their installation.}

\item{pip}{Logical (\code{TRUE}/\code{FALSE}). Use pip for package installation? This
is only relevant when Conda environments are used, as otherwise packages
will be installed from the Conda repositories.}

\item{required}{Logical (\code{TRUE}/\code{FALSE}). Is the requested copy of Python required?
If TRUE, an error will be emitted if the requested copy of Python does not exist.
If FALSE, the request is taken as a hint only, and scanning for other versions
will still proceed. See \code{\link[reticulate:use_python]{reticulate::use_condaenv()}} for more details.}
}
\value{
a named list of specifications pertaining to the python environment,
including the packages that are installed there.
}
\description{
Set up a python environment with required packages
}
\details{
An environment will be required for each new R session.

For a virtual environment, the user would be installing these packages \emph{every time}
they want to run python on a clean R session. It is a smaller package size that
a conda environment.

For a conda environment, users only need to install the required packages once. This
may be less ideal if many python modules are required, or you are developing an R package.

see \code{?reticulate::py_install} for more details

Inspired from \code{reticulate:::find_conda()}, though this function
will return all paths instead of the first one found in a hierarchy of priorities
}
\section{Functions}{
\itemize{
\item \code{install_py_pkgs()}: Install python packages to a python environment

\item \code{get_conda_paths()}: Search for conda installations

}}
\note{
You must restart your R session if you want to alternate between both environment types
}
\examples{
\dontrun{

## With a conda environment (the default) ##
py_env <- setup_py_env(py_pkgs = c("pandas", "numpy", "scipy"))
py_env

# Specify a specific conda environment and conda installation
conda_envs <- reticulate::conda_list()
conda_paths <- pythonR::get_conda_paths()

py_env <- setup_py_env(
  py_pkgs = c("pandas", "numpy", "scipy", "tiktoken"),
  conda_path = conda_paths[1],
  conda_env = conda_envs$python[1],
  required = TRUE,
  update = TRUE,
  pip = TRUE
)


# Installing a package after setup (works with both environment types)
py_env <- setup_py_env(py_pkgs = c("pandas", "numpy"), py_env = "conda")
install_py_pkgs(py_pkgs = c('scipy'), env_name = py_env$env_name)

# Check that installed modules can be imported
check_py_pkgs_installed(c("pandas", "numpy", "scipy"))


## With a virtual environment ##
py_env <- setup_py_env(py_pkgs = c("pandas", "numpy", "scipy"), py_env = "virtual")
py_env

# shutdown virtual environment
shutdown_virtual_env(py_env$env_name)

}

}
\seealso{
\link{import_py_pkgs}
}
